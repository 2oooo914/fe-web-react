[
        {
            "id": 1,
            "user": {
                "id": 3,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 3,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "A+B",
            "link": "https://www.acmicpc.net/problem/1000",
            "description": "두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 A와 B가 주어진다. (0 < A, B < 10)",
            "output_description": "첫째 줄에 A+B를 출력한다.",
            "memory_limit": 128,
            "time_limit": 1.0,
            "created_at": "2024-06-03T13:24:06.988383Z",
            "updated_at": "2024-06-03T13:24:06.988446Z"
        },
        {
            "id": 2,
            "user": null,
            "analysis": [
                {
                    "id": 1,
                    "problem": 1,
                    "difficulty": 1,
                    "tags": [
                        {
                            "id": 2,
                            "key": "arithmetic",
                            "name_ko": "산술",
                            "name_en": "arithmetic",
                            "parent": null
                        },
                        {
                            "id": 1,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics",
                            "parent": null
                        }
                    ],
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "1",
                    "created_at": "2024-07-10T05:48:30.959434Z"
                }
            ],
            "title": "피보나치 함수",
            "link": "https://www.acmicpc.net/problem/1003",
            "description": "다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.\r\n\r\nint fibonacci(int n) {\r\n    if (n == 0) {\r\n        printf(\"0\");\r\n        return 0;\r\n    } else if (n == 1) {\r\n        printf(\"1\");\r\n        return 1;\r\n    } else {\r\n        return fibonacci(n‐1) + fibonacci(n‐2);\r\n    }\r\n}\r\nfibonacci(3)을 호출하면 다음과 같은 일이 일어난다.\r\n\r\nfibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.\r\nfibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.\r\n두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.\r\nfibonacci(0)은 0을 출력하고, 0을 리턴한다.\r\nfibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.\r\n첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.\r\nfibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.\r\n1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 테스트 케이스의 개수 T가 주어진다.\r\n\r\n각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.",
            "output_description": "각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.",
            "memory_limit": 128,
            "time_limit": 2.5,
            "created_at": "2024-06-03T18:24:21.358190Z",
            "updated_at": "2024-06-03T18:24:21.358210Z"
        },
        {
            "id": 3,
            "user": null,
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 2,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "1",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "평점 변환",
            "link": "https://www.acmicpc.net/problem/31799",
            "description": "2023학년도까지 대구과고에서는 학생들의 한 학기 동안의 성적에 따라 A+, A0, A-, B+, B0, B-, C+, C0, C-의 아홉 가지 평어 가운데 하나를 부여하였다. 그러나 상대평가 중심의 평어 체제는 학생들 간의 과도한 경쟁을 유도하는 부작용이 있었다. 그래서 2024학년도부터는 B(Beginning), D(Developing), P(Proficient), E(Exceeding)의 네 가지 평어 가운데 하나를 부여하는 방식으로 체제를 바꿀 계획이다. 새로운 평어 체제는 상대평가 기간이 아닌 개인의 성장 과정에 따라 평어가 부여되는 방식이므로 기존 평어 체제의 문제점을 해결할 것으로 기대하고 있다.\r\n\r\n대구과고 학생들은 2023학년도 이전과 2024학년도 이후의 평어 체제가 완전히 달라서 자신의 발전 과정을 정확하게 알기 어려워졌다. 이에 따라 2023학년도 이전의 평어를 새로운 평어 체제에 맞추어 변환하는 공식적인 기준을 발표하였다.\r\n\r\n평어가 C+, C0, C- 가운데 하나이면, 새로운 평어는 B이다.\r\n평어가 B0, B- 가운데 하나이면\r\n첫 학기이거나 이전 학기의 평어가 C+, C0, C- 가운데 하나이면, 새로운 평어는 D이다.\r\n이전 학기의 평어가 A+, A0, A-, B+, B0, B- 가운데 하나이면, 새로운 평어는 B이다.\r\n평어가 A-, B+ 가운데 하나이면\r\n첫 학기이거나 이전 학기의 평어가 B0, B-, C+, C0, C- 가운데 하나이면, 새로운 평어는 P이다.\r\n이전 학기의 평어가 A+, A0, A-, B+ 가운데 하나이면, 새로운 평어는 D이다.\r\n평어가 A0이면\r\n첫 학기이거나 이전 학기의 평어가 A-, B+, B0, B-, C+, C0, C- 가운데 하나이면, 새로운 평어는 E이다.\r\n이전 학기의 평어가 A+, A0 가운데 하나이면, 새로운 평어는 P이다.\r\n평어가 A+이면 새로운 평어는 E이다.\r\n대구과고에 다니는 은성이는 기존 평어 체제로 부여되었던 자신의 $N$학기 동안의 평어를 새로운 평어 체제에 맞게 변환하고 싶다. 하지만 평어 변환 기준이 너무 복잡해 여러분에게 대신 이 일을 맡기려고 한다. $N$학기 동안의 평어가 첫 학기부터 $N$번째 학기까지 순서대로 공백 없이 주어질 때, 새로운 평어 체제에 맞게 변환한 결과를 출력하는 프로그램을 작성하라. 단, 은성이는 A0, B0, C0에서 실수로 0을 생략하여 'A', 'B', 'C'와 같이 적을 때도 있다고 한다.",
            "input_description": "첫 번째 줄에 은성이가 대구과고에 다닌 학기의 수 $N$이 주어진다.\r\n\r\n두 번째 줄에 은성이의 $N$학기 동안의 평어를 공백 없이 순서대로 나열한 문자열이 주어진다.\r\n\r\n $1\\le N\\le 200\\,000$",
            "output_description": "은성이의 $N$학기 동안의 평어를 새로운 체제에 맞게 변환한 결과를 첫 학기부터 공백 없이 순서대로 나열한 길이 $N$의 문자열을 출력한다.",
            "memory_limit": 1024000000,
            "time_limit": 1000,
            "created_at": "2024-06-16T13:51:26.551732Z",
            "updated_at": "2024-06-16T13:51:26.551746Z"
        },
        {
            "id": 4,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 3,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "CCW",
            "link": "https://www.acmicpc.net/problem/11758",
            "description": "2차원 좌표 평면 위에 있는 점 3개 P1, P2, P3가 주어진다. P1, P2, P3를 순서대로 이은 선분이 어떤 방향을 이루고 있는지 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 P1의 (x1, y1), 둘째 줄에 P2의 (x2, y2), 셋째 줄에 P3의 (x3, y3)가 주어진다. (-10,000 ≤ x1, y1, x2, y2, x3, y3 ≤ 10,000) 모든 좌표는 정수이다. P1, P2, P3의 좌표는 서로 다르다.",
            "output_description": "P1, P2, P3를 순서대로 이은 선분이 반시계 방향을 나타내면 1, 시계 방향이면 -1, 일직선이면 0을 출력한다.",
            "memory_limit": 256,
            "time_limit": 1.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 5,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 2,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "Bottled-Up Feelings",
            "link": "https://www.acmicpc.net/problem/11759",
            "description": "Peter is expecting a large shipment of fuel oil, but he has a small problem (doesn’t everyone in these programming problems!). The only containers he has are a set of large bottles (each with the same volume) and a set of smaller bottles (also each with the same, but smaller volume). Given the volume of the shipment of oil, he would like to store the oil in the bottles so that all of the oil is stored, each bottle is filled to the top, and the minimum number of bottles is used. While Peter thinks he has solved this problem for his given bottle sizes, he often spends hours wondering what would happen if his bottles had different volumes (apparently Peter doesn’t lead the most exciting life).",
            "input_description": "The input consists of a single line containing three positive integers s v1 v2, where s ≤ 106 is the volume of the shipment, and v1, v2 ≤ 106 are the volumes of the two types of bottles, with v1 > v2.",
            "output_description": "Output the number of bottles of size v1 and the number of bottles of size v2 which satisfy Peter’s two conditions. If the conditions cannot be met, output Impossible.",
            "memory_limit": 256,
            "time_limit": 1.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 6,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 1,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "제곱 ㄴㄴ 수",
            "link": "https://www.acmicpc.net/problem/1016",
            "description": "어떤 정수 X가 1보다 큰 제곱수로 나누어 떨어지지 않을 때, 그 수를 제곱ㄴㄴ수라고 한다. 제곱수는 정수의 제곱이다. min과 max가 주어지면, min보다 크거나 같고, max보다 작거나 같은 제곱ㄴㄴ수가 몇 개 있는지 출력한다.",
            "input_description": "첫째 줄에 두 정수 min과 max가 주어진다.",
            "output_description": "첫째 줄에 min보다 크거나 같고, max보다 작거나 같은 제곱ㄴㄴ수의 개수를 출력한다.",
            "memory_limit": 512,
            "time_limit": 2.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 7,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 2,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "알 수 없는 문장",
            "link": "https://www.acmicpc.net/problem/1099",
            "description": "형택이와 그의 친구들은 자꾸 다른 사람들이 대화를 엿듣는 것이 짜증났다. 따라서, 새로운 언어를 만들었다. 이 언어에는 단어가 N개 있다. 그리고 이 언어의 문장은 단어를 공백없이 붙여쓴 것이다. 이 문장에서 각 단어는 0번 또는 그 이상 나타날 수 있다. 이 언어가 형택스러운 이유는 (특별한 이유는) 단어에 쓰여 있는 문자의 순서를 바꿔도 되기 때문이다. 이때, 원래 단어의 위치와 다른 위치에 있는 문자의 개수 만큼이 그 순서를 바꾼 단어를 만드는 비용이다. 예를 들어, abc란 단어가 있을 때, abc는 비용 0으로 만들 수 있고, acb, cba, bac는 비용 2로 바꿀 수 있고, bca, cab는 비용 3으로 바꿀 수 있다. 따라서, 한 문장을 여러 가지 방법으로 해석할 수 있다. 이때 비용의 최솟값을 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 문장이 주어진다. 문장의 길이는 최대 50이다. 둘째 줄에 단어의 개수 N이 주어지며, N은 50보다 작거나 같은 자연수이다. 셋째 줄부터 N개의 줄에 각 단어가 주어진다. 단어의 길이는 최대 50이다. 문장과 단어는 알파벳 소문자로만 이루어져 있다.",
            "output_description": "첫째 줄에 문제의 정답을 출력한다. 만약 문장을 해석할 수 없다면 -1을 출력한다.",
            "memory_limit": 128,
            "time_limit": 2.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 8,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 3,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "분산처리",
            "link": "https://www.acmicpc.net/problem/1009",
            "description": "재용이는 최신 컴퓨터 10대를 가지고 있다. 어느 날 재용이는 많은 데이터를 처리해야 될 일이 생겨서 각 컴퓨터에 1번부터 10번까지의 번호를 부여하고, 10대의 컴퓨터가 다음과 같은 방법으로 데이터들을 처리하기로 하였다. 1번 데이터는 1번 컴퓨터, 2번 데이터는 2번 컴퓨터, 3번 데이터는 3번 컴퓨터, ... , 10번 데이터는 10번 컴퓨터, 11번 데이터는 1번 컴퓨터, 12번 데이터는 2번 컴퓨터, ... 총 데이터의 개수는 항상 ab개의 형태로 주어진다. 재용이는 문득 마지막 데이터가 처리될 컴퓨터의 번호가 궁금해졌다. 이를 수행해주는 프로그램을 작성하라.",
            "input_description": "입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 정수 a와 b가 주어진다. (1 ≤ a < 100, 1 ≤ b < 1,000,000)",
            "output_description": "각 테스트 케이스에 대해 마지막 데이터가 처리되는 컴퓨터의 번호를 출력한다.",
            "memory_limit": 128,
            "time_limit": 1.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 9,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 1,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "수열의 합",
            "link": "https://www.acmicpc.net/problem/1024",
            "description": "N과 L이 주어질 때, 합이 N이면서, 길이가 적어도 L인 가장 짧은 연속된 음이 아닌 정수 리스트를 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 N과 L이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이고, L은 2보다 크거나 같고, 100보다 작거나 같은 자연수이다.",
            "output_description": "만약 리스트의 길이가 100보다 작거나 같으면, 연속된 수를 첫째 줄에 공백으로 구분하여 출력한다. 만약 길이가 100보다 크거나 그러한 수열이 없을 때는 -1을 출력한다.",
            "memory_limit": 128,
            "time_limit": 2.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 10,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 1,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "용액",
            "link": "https://www.acmicpc.net/problem/2467",
            "description": "KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다. 같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.  예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다. 산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.",
            "output_description": "첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.",
            "memory_limit": 128,
            "time_limit": 1.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 11,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 3,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "The Sound of Silence",
            "link": "https://www.acmicpc.net/problem/2433",
            "description": "디지털 음악에서 소리는 대기압의 변화를 나타내는 숫자로 표현한다. 대기압의 변화는 일정한 시간 구간을 정해놓고, 연속되는 구간동안 얼마나 빠르게 변했는지를 측정한다. 이렇게 측정한 값을 샘플이라고 한다. 음성 처리에서 가장 중요한 단계는 녹음된 소리를 사일런스 기준으로 사일런스가 아닌 구간으로 나누는 작업이다. 너무 많은 조각이 나는 것을 방지 하기 위해서 사일런스는 최저값과 최고값의 차이가 c를 넘지않는 샘플 m개의 연속이라고 정의한다. 샘플 n개 이루어진 레코딩과 m과 c가 주어졌을 때, 사일런스를 찾는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 샘플의 수 n (1 ≤ n ≤ 1,000,000), m (1 ≤ m ≤ 10,000), c (0 ≤ c ≤ 10,000)가 주어진다. 둘째 줄에는 각 샘플의 값 ai가 주어진다. (0 ≤ ai ≤ 1,000,000 for 1 ≤ i ≤ n)",
            "output_description": "max(a[i . . . i+m−1])−min(a[i . . . i+m−1]) ≤ c를 만족하는 모든 i를 오름차순으로 한 줄에 하나씩 출력한다. 만약, 주어진 입력에 사일런스가 없다면, NONE을 출력한다.",
            "memory_limit": 128,
            "time_limit": 1.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 12,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 2,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "선분 덮기",
            "link": "https://www.acmicpc.net/problem/2024",
            "description": "X축 위에 여러 개의 짧은 선들이 흩어져 있다. 이 선들은 [Li, Ri]로 나타내는데 이는 선이 Li에서 시작해 Ri에서 끝남을 의미한다. 우리는 이들 중 적은 수의 선들만을 이용해서 [0, M]을 완전히 덮어 버리고 싶다. 최소 개수의 선들을 이용하여 [0, M]을 덮어버리는 프로그램을 작성하시오.",
            "input_description": "각 테스트 케이스는 M(1 ≤ M ≤ 50,000) 과 \"Li Ri\"(|Li|, |Ri| ≤ 50,000, i ≤ 100,000)쌍으로 구성이 된다. 각각은 다른 행으로 분리되어 있다. 입력은 \"0 0\"으로 끝난다. 모든 입력은 정수이다.",
            "output_description": "[0, M]을 덮는데 필요한 선의 개수를 출력한다. 만약 선을 덮는 방법이 존재하지 않으면 “0”을 출력하면 된다.",
            "memory_limit": 128.0,
            "time_limit": 2.0,
            "created_at": "2024-06-16T15:55:49.874302Z",
            "updated_at": "2024-06-16T15:55:49.874324Z"
        },
        {
            "id": 13,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 1,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "거짓말",
            "link": "https://www.acmicpc.net/problem/1043",
            "description": "지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다. 사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다. 둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다. 셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다. N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.",
            "output_description": "첫째 줄에 문제의 정답을 출력한다.",
            "memory_limit": 128.0,
            "time_limit": 2.0,
            "created_at": "2024-07-16T15:55:49.874302Z",
            "updated_at": "2024-07-16T15:55:49.874324Z"
        },
        {
            "id": 14,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 3,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "유니콘",
            "link": "https://www.acmicpc.net/problem/1048",
            "description": "유니콘은 체스에서 나이트와 비슷한 말이다. 단, 나이트는 두 칸을 한 방향으로 움직이고, 또 다른 한 칸을 다른 방향으로 움직이지만, 유니콘은 두 칸보다 많은 칸을 한 방향으로 움직이고, 한 칸보다 많은 칸을 또다른 방향으로 움직인다. 좀 더 정확하게 유니콘이 움직이는 방법을 살펴보면 다음과 같다. 1. 유니콘을 든다. 2.유니콘을 $4$개의 기본 방향 중 하나로 두 칸보다 많이 움직인다. 3.유니콘을 방금 움직인 방향과 수직인 방향 $2$개 중 하나로 한 칸보다 많이 움직인다. 4. 유니콘을 놓는다. 체스판의 크기는 $N \times M$이다. 체스판의 각 칸에는 알파벳 대문자의 처음 $L$개의 문자 중 하나가 쓰여 있다. $N$, $M$, $L$, 그리고 단어가 주어진다. 유니콘이 움직인 경로 (유니콘을 놓은 곳)가 입력으로 주어진 단어와 일치하는 경우의 수를 출력하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 $N$, $M$, $L$이 주어진다. $N$과 $M$은 $300$보다 작거나 같은 자연수이다. $L$은 $26$보다 작거나 같은 자연수이다. 둘째 줄에 단어가 주어진다. 단어의 길이는 최대 $50$이며, 알파벳 대문자로만 이루어져 있다. 셋째 줄 부터 $N$개의 줄에 체스판에 쓰여 있는 단어가 주어진다.",
            "output_description": "첫째 줄에 경로를 $1,000,000,007$로 나눈 나머지를 출력한다.",
            "memory_limit": 128,
            "time_limit": 2.0,
            "created_at": "2024-07-16T15:55:49.874302Z",
            "updated_at": "2024-07-16T15:55:49.874324Z"
        },
        {
            "id": 15,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "analysis": [
                {
                    "id": 1,
                    "tags": [
                        {
                            "id": 208,
                            "key": "implementation",
                            "name_ko": "구현",
                            "name_en": "implementation"
                        },
                        {
                            "id": 207,
                            "key": "math",
                            "name_ko": "수학",
                            "name_en": "mathematics"
                        }
                    ],
                    "difficulty": 1,
                    "hint": [
                        "그래프를 표현하기 위한 자료구조를 선택해야 합니다. 인접 행렬 또는 인접 리스트 중 하나를 선택하여 그래프를 표현할 수 있습니다.",
                        "DFS 탐색을 구현해야 합니다. 스택 자료구조를 사용하여 DFS 탐색을 구현할 수 있습니다. 시작 정점을 스택에 넣고, 스택에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 스택에 넣습니다.",
                        "BFS 탐색을 구현해야 합니다. 큐 자료구조를 사용하여 BFS 탐색을 구현할 수 있습니다. 시작 정점을 큐에 넣고, 큐에서 정점을 하나씩 꺼내면서 방문하지 않은 인접 정점들을 큐에 넣습니다.",
                        "DFS와 BFS 탐색 결과를 출력해야 합니다. 방문 순서대로 정점 번호를 출력하면 됩니다.",
                        "정점 번호가 작은 것을 먼저 방문하도록 구현해야 합니다. 인접 정점들을 방문할 때, 정점 번호가 작은 것부터 방문하도록 정렬하면 됩니다.",
                        "더 이상 방문할 수 있는 점이 없는 경우 종료하도록 구현해야 합니다. 모든 정점을 방문했거나, 더 이상 방문할 수 있는 인접 정점이 없는 경우 탐색을 종료하면 됩니다."
                    ],
                    "time_complexity": "N",
                    "created_at": "2024-06-03T13:26:04.696473Z"
                }
            ],
            "title": "친구",
            "link": "https://www.acmicpc.net/problem/1058",
            "description": "지민이는 세계에서 가장 유명한 사람이 누구인지 궁금해졌다. 가장 유명한 사람을 구하는 방법은 각 사람의 2-친구를 구하면 된다. 어떤 사람 A가 또다른 사람 B의 2-친구가 되기 위해선, 두 사람이 친구이거나, A와 친구이고, B와 친구인 C가 존재해야 된다. 여기서 가장 유명한 사람은 2-친구의 수가 가장 많은 사람이다. 가장 유명한 사람의 2-친구의 수를 출력하는 프로그램을 작성하시오. A와 B가 친구면, B와 A도 친구이고, A와 A는 친구가 아니다.",
            "input_description": "첫째 줄에 사람의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 각 사람이 친구이면 Y, 아니면 N이 주어진다.",
            "output_description": "첫째 줄에 가장 유명한 사람의 2-친구의 수를 출력한다.",
            "memory_limit": 128,
            "time_limit": 2.0,
            "created_at": "2024-07-16T15:55:49.874302Z",
            "updated_at": "2024-07-16T15:55:49.874324Z"
        },
        {
            "id": 16,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "title": "스티커 수집",
            "link": "https://www.acmicpc.net/problem/1093",
            "description": "영훈이의 취미는 스티커 수집이다. 서로 다른 스티커가 N개가 있고, 모두 번호가 0번부터 N-1번까지 매겨져 있다. 각 스티커는 한 개뿐이다. 각 스티커의 가격과 가치가 주어진다. 그리고, 영훈이가 현재 가지고 있는 스티커도 주어진다. 이때, 영훈이는 스티커를 팔고 사는 행동을 반복해서 가지고 있는 스티커의 가치의 합이 적어도 K가 되게 하려고 한다. 영훈이가 처음에 돈이 얼마가 있어야 영훈이가 가지고 있는 스티커의 가치의 합이 적어도 K가 되는지를 구하시오. 가능한 돈이 한 개가 아니라면 가장 작은 값을 출력한다.",
            "input_description": "첫째 줄에 N이 주어진다. N은 32보다 작거나 같은 자연수이다. 둘째 줄에는 각 스티커의 가격이 주어진다. 셋째 줄에는 각 스티커의 가치가 주어진다. 넷째 줄에는 K가 주어진다. 다섯째 줄에는 영훈이가 현재 가지고 있는 스티커의 개수가 주어진다. 여섯째 줄에는 영훈이가 가지고 있는 스티커의 번호가 주어진다. 가격은 30,000,000보다 작거나 같은 자연수이고, 영훈이가 가지고 있는 스티커의 개수는 0보다 크거나 같고, N보다 작거나 같은 정수이다. K는 0보다 크거나 같고, 1,000,000,000보다 작거나 같은 정수이다. 가치는 1 이상 30,000,000 이하의 정수이다. 영훈이가 가지고 있는 스티커의 수가 0인 경우 여섯번째 줄은 주어지지 않는다.",
            "output_description": "첫째 줄에 문제의 정답을 출력한다. 만약 불가능 할 때는 -1을 출력한다.",
            "memory_limit": 512,
            "time_limit": 2.0,
            "created_at": "2024-07-16T15:55:49.874302Z",
            "updated_at": "2024-07-16T15:55:49.874324Z"
        },
        {
            "id": 17,
            "user": {
                "id": 1,
                "boj_user": {
                    "id": 1,
                    "boj_id": "hepheir",
                    "is_verified": false,
                    "level": 16,
                    "updated_at": "2024-06-03T14:14:42.517097Z",
                    "user": 3
                },
                "image": "http://192.168.20.32:8000/media/user_images/%EC%88%98%EB%AD%89%EC%9D%B4.png",
                "username": "hepheir",
                "email": "hepheir@gmail.com"
            },
            "title": "레슬링 팀 선발",
            "link": "https://www.acmicpc.net/problem/9423",
            "description": "대한 레슬링 협회는 다가오는 올림픽 선발전을 대비하기 위해 소속 선수들을 두 팀으로 나누려고 한다. 모든 선수는 두 팀 중 하나에 소속되어야 한다. 또, 두 팀에 소속된 선수의 차이는 1을 넘어갈 수 없다. 마지막으로, 각 팀의 몸무게의 합의 차이는 최소가 되어야 한다. 모든 선수들의 몸무게가 주어졌을 때, 위의 조건을 지키면서 팀을 나눈 다음, 각 팀의 몸무게의 합을 구하는 프로그램을 작성하시오.",
            "input_description": "첫째 줄에 선수의 수 n이 주어진다. 다음 n개 줄에는 각 선수의 몸무게가 주어진다. 몸무게는 1보다 크거나 같고, 450보다 작거나 같은 정수이다. 협회에 소속된 선수의 수는 100명을 넘지 않는다.",
            "output_description": "각 팀의 몸무게의 합을 공백으로 구분해 출력한다. 합이 작은 것을 먼저 출력한다.",
            "memory_limit": 128.0,
            "time_limit": 1.0,
            "created_at": "2024-07-16T15:55:49.874302Z",
            "updated_at": "2024-07-16T15:55:49.874324Z"
        }
    ]